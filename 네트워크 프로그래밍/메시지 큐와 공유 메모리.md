# 메시지 큐와 공유 메모리

### IPCS

- IPC 관련 시스템에서 관리되고 있는 상태들을 출력하는 명령어

### 메시지 큐

- Message Queue
- 프로세스간 블록단위의 메시지 송수신을 위한 운영체제에서 제공되는 서비스, FIFO나 PIPE와는 달리 다수의 송신자와 수신자가 존재할 수 있음

### 공유 메모리

- Shared Memory
- 운영체제에 의해 관리되고 제공되는 특별한 메모리 공간으로 이를 요청한 프로세스에게 제공하여, 허용된 프로세스들이 그 공통된 공간을 접근

---

---

## 메시지 큐 (Message Queue)

### 개념

- 데이터를 넣는것 = 인큐
- 데이터를 빼는것 = 디큐

- 프로세스간 `메시지(블록)단위의 통신`이 가능하도록 운영체제에 의해 제공
- 송신된 메시지는 운영체제에 의해 순차적으로 적재
- 클라이언트 프로그램에 의해 수신된 메시지는 운영체제가 삭제
- PIPE나 FIFO와는 달리 `다수의 프로세스간 메시지를 전달` 할 수 있음
- 메시지의 접근을 위해서는 키(key)가 필요

```
사용 절차
    프로세스 A : 메시지 큐를 생성
    프로세스 A : 메시지를 메시지 큐에 송신 (운영체제가 보관)
    프로세스 B : 메시지 큐를 생성
    프로세스 B : 메시지 큐에서 수신 (운영체제는 삭제)
```

### 시스템상 IPC 정보 제어

- `ipcs`

  - IPC 확인 명령어
  - 시스템에 등록된 리스트 및 관련 정보 등을 볼 수 있음
  - 옵션
    - -m 공유 메모리
    - -s 세마포어 (동시접근 방지)
    - -q 메시지큐

- `ipcrm [key]`
  - IPC 삭제 명령어
  - 인자로 주어진 키(key)에 해당하는 ipc가 삭제됨

### 메시지 큐 생성 함수

- `int msgget(key_t key, int msgflg)`
  - key
    - 시스템에서 식별하기 위한 메시지 큐 번호
  - msgflg
    - 동작 옵션
  - 반환값
    - 실패 시 -1 반환
    - 성공 시 식별자를 반환

### 메시지 송신

- `int msgsnd(int msgld, const void *msgp, size_t msgSz, int msgFlg)`

  - msgld
    - 메시지 큐 식별자
  - msgp
    - 송신할 메시지의 주소
  - msgSz
    - 송신할 메시지의 크기 (바이트)
  - 메세지 크기
    - sizeof(struct msgbuf) - sizeof(long)
  - msgFlg
    - 동작 옵션
    - IPC_CREAT
      - 메시지 큐가 없으면 생성
    - IPC_EXCL
      - 생성 시 중복된 키가 있으면 실패
    - IPC_NOWAIT
      - 메시지 큐가 가득 차 더 이상 저장할 수 없을 경우 -1을 반환

- 반환값
  - 성공 시 0
  - 실패 시 -1

### 메시지 수신

- `int msgrcv(int msgld, const void *msgp, size_t msgSz, long msgTyp, int msgFlg`
  - msgld
    - 메시지 큐 식별자
  - msgp
    - 메시지를 저장할 주소
  - msgSz
    - 수신할 메시지의 크기
  - msgTyp
    - 수신할 메시지의 타입 (단, 0일 때 첫 번째 메시지를 수신)
  - msgFlg
    - 동작 옵션
      - IPC_NOWAIT
        - 메시지 큐가 없으면 -1을 반환, 미정의 시 블록킹
      - MSG_NOERROR
        - msgSz 보다 사이즈가 클 때, 초과분은 버림, 미정의 시 초과 시 -1 반환
- 반환값
  - 성공 시 메시지 크기
  - 실패 시 -1

---

## 공유 메모리 (Shared Memory)

- 서로 다른 프로세스가 공통된 메모리 공간을 사용할 수 있도록 운영체제에서 제공되는 서비스
- System V계열에서는 공유메모리 기법을 제공하며, BSD계열에서는 메모리맵(mmap) 기법을 제공하나 동작방식은 유사
- 메시지 큐와는 달리 트랜잭션 개념이 없음 (동시 접근에 따른 데이터 깨짐이 발생)
- 동시접근 문제를 해결하기 위해 별도의 기법이 필요 ex) 세마포어 (Semaphore)
  - 세마포어 - 데이터 락킹을 하는 기법
- `논리주소는 다르더라도 실질적인 주소는 같다`

```
사용 절차

    프로세스 A : 공유 메모리 생성

    프로세스 A : 생성된 공유메모리 영역을 자신의 메모리 영역에 첨부 (Attach)

    프로세스 A : 첨부된 영역에 접근 (Read/ Write)

    ---
    프로세스 B : 생성된 공유메모리 영역을 자신의 메모리 영역에 첨부 (Attach)

    프로세스 B : 첨부된 영역에 접근 (Read/ Write)

    프로세스 A & B : 첨부도니 영역을 분리 (Detach)
```

- 공유메모리가 운영체제에 의해 삭제 되었다고 해도 사라지지 않는다

### 공유메모리 생성 함수

- `int shmget(key_t key, size_t size, int shmflg)`

  - key
    - 시스템에서 식별하기 위한 공유메모리 번호
  - size
    - 공유메모리 크기
  - shmflg
    - 동작옵션 (메시지 큐와 같음)

- 반환값
  - 성공 시 공유메모리 식별자
  - 실패 시 -1

### 공유메모리 첨부 함수

- `int shmat(int shmId, const void *shmAddr, int shmFlg)`

  - shmId
    - 공유메모리 식별자
  - shmAddr
    - 붙여 넣을 메모리 주소가 되며, 운영체제에서 자동으로 할당을 원할 경우 NULL 값을 사용
  - shmFlg
    - SHM_RDONLY
      - 공유 영역에 대한 읽기 모드로 접근
    - SHM_RND
      - shmAddr이 NULL이 아닐때 사용자 지정영역을 공유공간으로 설정

- 반환값
  - 성공 시 공유메모리 주소를 반환
  - 실패 시 -1

### 공유메모리 분리 함수

- `int shmdt(const void *shmaddr)`
  - shaaddr
    - 분리할 공유메모리 주소
- 반환값
  - 성공 시 사용되었던 공유메모리 주소를 반환
  - 실패 시 -1
